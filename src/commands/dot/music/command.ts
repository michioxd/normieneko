import { EmbedBuilder, Events, Message } from "discord.js";
import { StreamType, VoiceConnection, createAudioPlayer, createAudioResource, joinVoiceChannel } from "@discordjs/voice";
import crypto from "crypto";

import { globalPrefix, serverId } from "../../../index.js";
import client from "../../../client.js";
import { CreateVoiceInstance, CurrentPlayerInstance, CurrentPlayingUUID, CurrentVoiceChannelId, CurrentVoiceInstance, DestoryInstance, HandlePlayingSession } from "./player.js";
import { getYouTubeVideoId, isValidUrl, isYouTubePlaylist, isYouTubeWatchUrl } from "../../../utils/utils.js";
import { Playlist } from "../../../db.js";
import axios from "axios";
import { YouTubeAPIType } from "../../../types/YouTubeVideoType.js";
import ytdl from "ytdl-core";

const evt = {
    name: Events.MessageCreate,
    once: false,
    execute: async (ct: Message) => {
        // we will prevent it simbot channel
        if (ct.channelId === "1139181936053583904") return;

        if (!ct.content.startsWith(globalPrefix)) return;

        const msg = ct.content.slice(1, ct.content.length).split(" ");

        if (msg[0] === "play" || msg[0] === "stop" || msg[0] === "skip" || msg[0] === "queue") {
            const guild = client.guilds.cache.get(serverId);
            const mem = guild.members.cache.get(ct.author.id);

            if (!mem.voice.channel) {
                ct.reply("**‚ùå L·ªói**: B·∫°n ch∆∞a v√†o m·ªôt voice channel n√†o c·∫£, h√£y v√†o 1 voice channel b·∫•t k·ª≥ sau ƒë√≥ th·ª≠ l·∫°i!");
                return;
            }

            const voiceChannel = mem.voice.channel;

            switch (msg[0]) {
                case "play":

                    if (CurrentVoiceInstance !== null && CurrentVoiceChannelId !== voiceChannel.id) {
                        ct.reply("**‚ùå L·ªói**: B·∫°n ƒë√£ v√†o channel m√† kh√¥ng c√≥ bot ·∫¢o ·∫¢nh Xanh ƒëang ·ªü trong ƒë√≥, vui l√≤ng chuy·ªÉn qua channel c√≥ bot AAX!");
                    }

                    if (msg[1].length < 1) {
                        ct.reply("**‚ùå L·ªói**: Vui l√≤ng cung c·∫•p t·ª´ kho√° t√¨m ki·∫øm ho·∫∑c li√™n k·∫øt t·ªõi video/playlist tr√™n YouTube!");
                        return;
                    }

                    if (isValidUrl(msg[1])) {
                        if (!isYouTubeWatchUrl(msg[1]) && !isYouTubePlaylist(msg[1])) {
                            await ct.reply("**‚ùå L·ªói**: Hi·ªán t·∫°i ch·ªâ h·ªó tr·ª£ li√™n k·∫øt c·ªßa YouTube!");
                            return;
                        }

                        if (isYouTubeWatchUrl(msg[1])) {
                            const rp = await ct.reply("*<a:aax_vailolae:1132367020856442940> ƒêang l·∫•y d·ªØ li·ªáu, vui l√≤ng ch·ªù...*")
                            try {
                                const res = await ytdl.getBasicInfo(msg[1]);
                                if (res) {
                                    const details = res.videoDetails;
                                    const embed = new EmbedBuilder()
                                        .setAuthor({
                                            name: details.author.name,
                                            url: details.author.channel_url,
                                            iconURL: details.author.thumbnails[0].url,
                                        })
                                        .setTitle(details.title)
                                        .setURL(details.video_url)
                                        .setDescription(`ƒê√£ th√™m v√†o h√†ng ch·ªù - b·ªüi <@!${ct.author.id}>`)
                                        .setImage(details.thumbnails[details.thumbnails.length - 1].url)
                                        .setColor("#f50018")
                                        .setFooter({
                                            text: "·∫¢o ·∫¢nh Xanh",
                                            iconURL: "https://cdn.discordapp.com/attachments/1132959792072237138/1135220931472654397/3FA86C9B-C40F-456A-A637-9D6C39EAA38B.png",
                                        })
                                        .setTimestamp();

                                    await Playlist.create({
                                        uid: crypto.randomUUID(),
                                        addedAt: Date.now(),
                                        addedBy: ct.author.id,
                                        url: details.video_url,
                                        played: 0,
                                        title: details.title,
                                        streamingType: 0,
                                        originalUrl: details.video_url
                                    });

                                    await rp.edit({
                                        content: "‚úÖ ƒê√£ th√™m v√†o h√†ng ch·ªù!",
                                        embeds: [embed]
                                    });

                                } else {
                                    ct.reply("**‚ùå L·ªói**: Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu c·ªßa video YouTube ƒë√≥, vui l√≤ng ki·ªÉm tra l·∫°i! *(L∆∞u √Ω: Video ri√™ng t∆∞ s·∫Ω kh√¥ng th·ªÉ ho·∫°t ƒë·ªông)*");
                                }

                            } catch (e) {
                                ct.reply("**‚ùå L·ªói**: Kh√¥ng th·ªÉ l·∫•y d·ªØ li·ªáu c·ªßa video YouTube ƒë√≥, vui l√≤ng ki·ªÉm tra l·∫°i! *(L∆∞u √Ω: Video ri√™ng t∆∞ s·∫Ω kh√¥ng th·ªÉ ho·∫°t ƒë·ªông)*");
                            }
                        }
                    }

                    if (CurrentVoiceInstance === null) {
                        CreateVoiceInstance(voiceChannel.id, guild.id, voiceChannel.guild.voiceAdapterCreator, voiceChannel);
                        await voiceChannel.send(`‚úÖ ƒê√£ v√†o channel **${voiceChannel.name}**!`);
                    }

                    break;
                case "skip":

                    if (CurrentVoiceInstance !== null && CurrentVoiceChannelId !== voiceChannel.id) {
                        ct.reply("**‚ùå L·ªói**: B·∫°n ƒë√£ v√†o channel m√† kh√¥ng c√≥ bot ·∫¢o ·∫¢nh Xanh ƒëang ·ªü trong ƒë√≥, vui l√≤ng chuy·ªÉn qua channel c√≥ bot AAX!");
                    } else if (CurrentVoiceInstance === null) {
                        ct.reply("**‚ùå L·ªói**: Hi·ªán t·∫°i ƒëang kh√¥ng ph√°t ·ªü b·∫•t c·ª© k√™nh n√†o!");
                        return;
                    }

                    const track = await Playlist.findOne({
                        where: { played: 0 }, order: [
                            ['id', 'ASC'],
                        ]
                    });

                    await Playlist.update({ played: 1 }, { where: { uid: track.uid } });

                    HandlePlayingSession(3);

                    await voiceChannel.send(`‚úÖ ƒê√£ b·ªè qua b√†i hi·ªán t·∫°i!`);

                    break;
                case "stop":
                    if (CurrentVoiceInstance !== null && CurrentVoiceChannelId !== voiceChannel.id) {
                        ct.reply("**‚ùå L·ªói**: B·∫°n ƒë√£ v√†o channel m√† kh√¥ng c√≥ bot ·∫¢o ·∫¢nh Xanh ƒëang ·ªü trong ƒë√≥, vui l√≤ng chuy·ªÉn qua channel c√≥ bot AAX!");
                    } else if (CurrentVoiceInstance === null) {
                        ct.reply("**‚ùå L·ªói**: Hi·ªán t·∫°i ƒëang kh√¥ng ph√°t ·ªü b·∫•t c·ª© k√™nh n√†o!");
                        return;
                    }

                    DestoryInstance();
                    await Playlist.update({ played: 1 }, { where: {} });
                    voiceChannel.send("**üõë ƒê√£ d·ª´ng!**");
                    break;

                case "queue":

                    if (msg[1] === "clear") {
                        await Playlist.destroy({
                            where: {},
                            truncate: true
                        });
                        await ct.reply("üóëÔ∏è ƒê√£ xo√° to√†n b·ªô h√†ng ch·ªù!");
                        return;
                    }

                    const getPage = msg[1] ? parseInt(msg[1]) : 1;
                    const page = getPage <= 0 ? 1 : getPage;

                    const pageOffset = (page - 1) * 10;

                    const queue = await Playlist.findAll({ where: { played: 0 }, order: [['id', 'ASC']], limit: 10, offset: pageOffset });

                    if (queue.length < 1) {
                        await ct.reply("‚õî H√†ng ch·ªù tr·ªëng, h√£y th√™m 1 b√†i h√°t n√†o ƒë√≥ b·∫±ng c√°ch d√πng l·ªánh `;play <li√™n k·∫øt video YouTube>`");
                        return;
                    }

                    const totalQuery = await Playlist.count({ where: { played: 0 } });
                    const totalPage = Math.ceil(totalQuery / 10);

                    let records = "";

                    for (let i = 0; i < queue.length; i++) {
                        if (queue[i].uid === CurrentPlayingUUID) {
                            records += `‚ñ∂Ô∏è **${i + 1}. [${queue[i].title}](${queue[i].originalUrl})\n**`;
                        } else {
                            records += `${i + 1}. [${queue[i].title}](${queue[i].originalUrl})\n`;
                        }
                    }

                    await ct.reply({
                        embeds: [{
                            author: {
                                name: "üìö Dach s√°ch h√†ng ch·ªù"
                            },
                            description: `${records}\nüìñ Trang **${page}** tr√™n **${totalPage}** trong t·ªïng s·ªë **${totalQuery}**${page + 1 <= totalPage ? `\n‚ñ∂Ô∏è Qua trang ti·∫øp theo: \`;queue ${page + 1}\`` : ""}\nüóëÔ∏è Xo√° t·∫•t c·∫£: \`;queue clear\``,
                            footer: {
                                text: "·∫¢o ·∫¢nh Xanh",
                                icon_url: "https://cdn.discordapp.com/attachments/1132959792072237138/1135220931472654397/3FA86C9B-C40F-456A-A637-9D6C39EAA38B.png"
                            }
                        }]
                    });

                    break;
            }
        }
    }

}

export default evt;